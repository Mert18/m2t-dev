---
title: Learning Dynamic Programming
description: ChatGPT helps me to learn dynamic programming.
date: April, 14th. 2024
category: work,learning,ai
image: https://m2t-dev-static.fra1.digitaloceanspaces.com/posts/dynamic-programming/dynamic-programming.png
---

<Prompt>
  <Paragraph>Hi, I want to learn about dynamic programming. I want you to give short answers to my questions. But first, draw me a simple path learning this programming technique.</Paragraph>
</Prompt>

<AIResponse>
  <Paragraph>
    Dynamic programming (DP) is a powerful technique used in algorithms to solve problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid computing the same results multiple times. Here’s a simple path to learn dynamic programming:
  </Paragraph>
  <ul>
    <ListItemWithTitle title={"Understand the Concept of Recursion"} text={"Start with understanding recursion, as it's foundational for grasping how DP works. Practice simple recursive problems like factorial calculation, Fibonacci sequence, etc."} />
    <ListItemWithTitle title={"Learn the Basics of Dynamic Programming"} text={"Learn about the two key attributes of DP problems: optimal substructure and overlapping subproblems. Understand the difference between top-down (memoization) and bottom-up (tabulation) approaches."} />
    <ListItemWithTitle title={"Practice Simple DP Problems"} text={"Start with classic problems like Fibonacci sequence, rod cutting, coin change, and knapsack problem. Try solving these problems first using recursion and then improve them with DP to notice the efficiency gain."} />
    <ListItemWithTitle title={"Review and Reflect"} text={"Regularly revisit problems to improve both your approach and understanding. Try to teach DP concepts or write about them to solidify your knowledge."} />
  </ul>
</AIResponse>

<Prompt>
  <Paragraph>Does it always have to be recursive?</Paragraph>
</Prompt>

<AIResponse>
    <Paragraph>
        No, dynamic programming doesn't always have to involve recursion. While many dynamic programming solutions start with a recursive approach (which is then optimized using memoization), you can also use an iterative approach known as tabulation. Here’s a brief look at both:
    </Paragraph>
    <ul>
        <ListItemWithTitle title={"Memoization (Top-Down)"} text={"This approach involves storing the results of expensive function calls and returning the cached result when the same inputs occur again. It's a form of optimization over plain recursion."} />
        <ListItemWithTitle title={"Tabulation (Bottom-Up)"} text={"In this approach, you start by solving the smallest subproblems and build up to the larger problem. You fill up a table with the results of the subproblems and use them to solve the larger problem."} />
    </ul>
    <Paragraph>
        Both methods are valid in dynamic programming, and the choice between them often depends on the specific problem and personal or contextual preference.
    </Paragraph>
</AIResponse>

<Prompt>
    Before getting into memoization and tabulation, can you tell me more about optimal substructure and overlapping subproblems?
</Prompt>

<AIResponse>
    <Paragraph>
        Certainly! Understanding optimal substructure and overlapping subproblems is crucial for mastering dynamic programming. Here’s a brief explanation of each:
    </Paragraph>
    
    <ul>
        <ListItemWithTitle title={"Optimal Substructure"} text={"A problem exhibits optimal substructure if an optimal solution to the problem contains optimal solutions to its subproblems. This property allows you to break down a problem into smaller subproblems and solve them independently."} />
        <ListItemWithTitle title={"Overlapping Subproblems"} text={"A problem has overlapping subproblems if it can be broken down into subproblems that are reused multiple times. Dynamic programming takes advantage of this property by storing the results of subproblems to avoid redundant computations."} />
    </ul>

    <Paragraph>
        Dynamic programming exploits these two properties by combining the solutions to the overlapping subproblems stored from previous computations (memoization) or computed systematically (tabulation), thereby avoiding the recomputation and ensuring efficient solving of complex problems.
    </Paragraph>
</AIResponse>

<Prompt>
    <Paragraph>So I need to choose either memoization or tabulation approach to solve a problem using dynamic programming. But how do I understand which one should I choose? Can you give an example problem for both?</Paragraph>
</Prompt>

<AIResponse>
    <Paragraph>
        When deciding between memoization (top-down) and tabulation (bottom-up) for solving a dynamic programming problem, consider the following aspects:
    </Paragraph>

    <ul>
        <ListItemWithTitle title={"Memoization (Top-Down)"} text={"It is often simpler to implement as it's just recursion plus a memoization table. It also can be more memory efficient as not all states need to be computed; only those required will be but might be slightly slower due to overhead from recursive calls. Memoization is often preferred if you're unsure how many subproblems you'll need to solve since it only calculates necessary subproblems."} />
        <ListItemWithTitle title={"Tabulation (Bottom-Up)"} text={"Generally faster because of iterative approach and avoids the overhead of recursion. All states are computed, so it can be less memory efficient if not all states are needed. Tabulation is effective if you need a straightforward, iterative solution and can benefit from the performance advantage due to fewer overheads from recursive calls."} />
    </ul>
</AIResponse>

<Prompt>
    <Paragraph>I get it. Now get more into memoization and tabulation. Start with memoization.</Paragraph>
</Prompt>

<AIResponse>
    <Paragraph>
        Memoization is a technique used in dynamic programming to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again. It's particularly effective for problems where the same subproblems are solved multiple times. Here’s a deeper look into memoization:
    </Paragraph>

    <Paragraph>
        In Java, you can implement memoization manually by using a HashMap to store the results of function calls. Here's how you can implement the Fibonacci sequence using memoization in Java, without using any specific library for memoization:
    </Paragraph>

    ```java
        import java.util.HashMap;
        import java.util.Map;

        public class Fibonacci {
            private Map<Integer, Long> memo = new HashMap<>(); // HashMap to store memoized results

            public long fibonacci(int n) {
                if (n <= 2) {
                    return 1;
                }
                if (memo.containsKey(n)) { // Check if result is already memoized
                    return memo.get(n);
                }
                // Compute and memoize the result
                long result = fibonacci(n - 1) + fibonacci(n - 2);
                memo.put(n, result);
                return result;
            }

            public static void main(String[] args) {
                Fibonacci fib = new Fibonacci();
                int n = 50; // Example: Calculate the 50th Fibonacci number
                System.out.println("Fibonacci number at position " + n + " is: " + fib.fibonacci(n));
            }
        }
    ```
    <br />
    <ul>
        <ListItemWithTitle title={"HashMap"} text={"This HashMap (memo) is used to store the computed Fibonacci numbers. Each number is calculated once, and its result is stored associated with its index."} />
        <ListItemWithTitle title={"Recursive Function"} text={"The fibonacci method uses recursion to compute Fibonacci numbers. It first checks if the number has already been computed and stored in the memo map. If not, it computes the number, stores it in the map, and then returns it."} />
        <ListItemWithTitle title={"Base Cases"} text={"For n <= 2, it directly returns 1 as the Fibonacci sequence starts with 1, 1, 2, etc."} />
    </ul>

    <Paragraph>This implementation effectively reduces the time complexity from exponential (in a naive recursive approach) to linear, as each unique call to fibonacci(n) is computed only once.</Paragraph>
</AIResponse>

<Prompt>
    <Paragraph>Now tell me about tabulation.</Paragraph>
</Prompt>

<AIResponse>
    <Paragraph>Tabulation is a dynamic programming approach that solves problems by building a table (usually an array or a matrix) iteratively and filling it from the bottom up. It's often referred to as the bottom-up approach in dynamic programming. Here’s a detailed look at how tabulation works:</Paragraph>

    <ul>
        <ListItemWithTitle title={"Initialize a Table"} text={"Start by initializing a table (often an array) that will store the results of subproblems."} />
        <ListItemWithTitle title={"Base Cases"} text={"Fill in the base cases directly into the table."} />
        <ListItemWithTitle title={"Iterative Filling"} text={"Use an iterative approach to fill the table from the smallest subproblem to the largest. This ensures that all the necessary information to solve a subproblem has already been computed and stored."} />
        <ListItemWithTitle title={"Return the Result"} text={"The answer to the original problem is usually found in the last cell of the array (or another specific position based on the problem)."} />
    </ul>  

    ```java
        public class FibonacciTabulation {
            public static long fibonacci(int n) {
                if (n <= 2) {
                    return 1;
                }
                long[] table = new long[n + 1]; // Create an array to hold the results of subproblems
                table[1] = 1; // Base case initialization
                table[2] = 1; // Base case initialization
                for (int i = 3; i <= n; i++) {
                    table[i] = table[i - 1] + table[i - 2]; // Fill the table iteratively
                }
                return table[n]; // The nth Fibonacci number is stored in table[n]
            }

            public static void main(String[] args) {
                int n = 50; // Example: Calculate the 50th Fibonacci number
                System.out.println("Fibonacci number at position " + n + " is: " + fibonacci(n));
            }
        }
    ```  
</AIResponse>